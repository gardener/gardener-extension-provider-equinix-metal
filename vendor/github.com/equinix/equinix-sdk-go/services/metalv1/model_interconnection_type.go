/*
Metal API

Contact: support@equinixmetal.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package metalv1

import (
	"encoding/json"
	"fmt"
)

// InterconnectionType The 'shared' type of interconnection refers to shared connections, or later also known as Fabric Virtual Connections (or Fabric VCs). The 'dedicated' type of interconnection refers to interconnections created with Dedicated Ports. The 'shared_port_vlan' type of interconnection refers to shared connections created without service tokens. The 'shared_port_vlan_to_csp' type of interconnection refers to connections created directly to a supported cloud service provider.
type InterconnectionType string

// List of Interconnection_type
const (
	INTERCONNECTIONTYPE_SHARED                  InterconnectionType = "shared"
	INTERCONNECTIONTYPE_DEDICATED               InterconnectionType = "dedicated"
	INTERCONNECTIONTYPE_SHARED_PORT_VLAN        InterconnectionType = "shared_port_vlan"
	INTERCONNECTIONTYPE_SHARED_PORT_VLAN_TO_CSP InterconnectionType = "shared_port_vlan_to_csp"
)

// All allowed values of InterconnectionType enum
var AllowedInterconnectionTypeEnumValues = []InterconnectionType{
	"shared",
	"dedicated",
	"shared_port_vlan",
	"shared_port_vlan_to_csp",
}

func (v *InterconnectionType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := InterconnectionType(value)
	for _, existing := range AllowedInterconnectionTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid InterconnectionType", value)
}

// NewInterconnectionTypeFromValue returns a pointer to a valid InterconnectionType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewInterconnectionTypeFromValue(v string) (*InterconnectionType, error) {
	ev := InterconnectionType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for InterconnectionType: valid values are %v", v, AllowedInterconnectionTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v InterconnectionType) IsValid() bool {
	for _, existing := range AllowedInterconnectionTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to Interconnection_type value
func (v InterconnectionType) Ptr() *InterconnectionType {
	return &v
}

type NullableInterconnectionType struct {
	value *InterconnectionType
	isSet bool
}

func (v NullableInterconnectionType) Get() *InterconnectionType {
	return v.value
}

func (v *NullableInterconnectionType) Set(val *InterconnectionType) {
	v.value = val
	v.isSet = true
}

func (v NullableInterconnectionType) IsSet() bool {
	return v.isSet
}

func (v *NullableInterconnectionType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableInterconnectionType(val *InterconnectionType) *NullableInterconnectionType {
	return &NullableInterconnectionType{value: val, isSet: true}
}

func (v NullableInterconnectionType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableInterconnectionType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
